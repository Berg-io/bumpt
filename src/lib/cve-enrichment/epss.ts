const EPSS_API = "https://api.first.org/data/v1/epss";

interface EpssRow {
  cve?: string;
  epss?: string;
}

function chunk<T>(items: T[], size: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i < items.length; i += size) {
    chunks.push(items.slice(i, i + size));
  }
  return chunks;
}

export async function queryEpssByCve(cves: string[]): Promise<Record<string, number>> {
  const normalized = [...new Set(cves.map((cve) => cve.toUpperCase()).filter((cve) => cve.startsWith("CVE-")))];
  if (normalized.length === 0) return {};

  const result: Record<string, number> = {};
  const batches = chunk(normalized, 50);

  for (const batch of batches) {
    try {
      const params = new URLSearchParams({ cve: batch.join(",") });
      const res = await fetch(`${EPSS_API}?${params}`, {
        headers: { Accept: "application/json" },
        signal: AbortSignal.timeout(15000),
      });
      if (!res.ok) continue;
      const data = await res.json() as { data?: EpssRow[] };
      const rows = data.data ?? [];
      for (const row of rows) {
        const cve = row.cve?.toUpperCase();
        if (!cve || !cve.startsWith("CVE-")) continue;
        const value = Number(row.epss);
        if (!Number.isFinite(value)) continue;
        // EPSS is a probability in range [0..1].
        result[cve] = Math.max(0, Math.min(1, value));
      }
    } catch {
      // Ignore EPSS errors per batch to keep enrichment resilient.
    }
  }

  return result;
}
