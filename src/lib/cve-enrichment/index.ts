import { prisma } from "@/lib/prisma";
import { getAppSetting } from "@/lib/settings";
import { queryOsv } from "./osv";
import { queryNvd } from "./nvd";
import { queryGitHubAdvisory } from "./github-advisory";
import { queryVulnDb } from "@/lib/version-checkers/vulndb";
import { publishCheckEvent } from "@/lib/check-events";

interface EnrichmentInput {
  id: string;
  name: string;
  currentVersion: string | null;
  latestVersion: string | null;
  sourceType: string;
  sourceParams: Record<string, string>;
}

interface EcosystemMapping {
  osvEcosystem: string | null;
  ghEcosystem: string | null;
  packageName: string | null;
  nvdKeyword: string;
}

interface CveProviderResult {
  source: "osv" | "nvd" | "github_advisory" | "vulndb";
  cves: string[];
}

function normalizeVersionParts(version: string | null | undefined): number[] {
  if (!version) return [];
  return version
    .replace(/^[^\d]*/, "")
    .replace(/[^0-9.].*$/, "")
    .split(".")
    .map((part) => Number(part))
    .filter((part) => Number.isFinite(part));
}

function compareNormalizedVersions(a: string | null | undefined, b: string | null | undefined): number {
  const ap = normalizeVersionParts(a);
  const bp = normalizeVersionParts(b);
  const max = Math.max(ap.length, bp.length);
  for (let i = 0; i < max; i++) {
    const av = ap[i] ?? 0;
    const bv = bp[i] ?? 0;
    if (av > bv) return 1;
    if (av < bv) return -1;
  }
  return 0;
}

function deriveStatusFromVersions(current: string | null, latest: string | null): "up_to_date" | "outdated" | "critical" {
  if (!current || !latest) return "up_to_date";
  if (current === latest) return "up_to_date";
  const currentMajor = normalizeVersionParts(current)[0];
  const latestMajor = normalizeVersionParts(latest)[0];
  if (
    latestMajor !== undefined &&
    currentMajor !== undefined &&
    latestMajor > currentMajor
  ) {
    return "critical";
  }
  return compareNormalizedVersions(latest, current) > 0 ? "outdated" : "up_to_date";
}

function isCveEnrichmentEnabled(setting: string | null): boolean {
  if (!setting) return false;
  const normalized = setting.trim().toLowerCase();
  return normalized === "true" || normalized === "1" || normalized === "yes" || normalized === "on";
}

const SOURCE_ECOSYSTEM_MAP: Record<string, { osv: string | null; gh: string | null; paramKey: string }> = {
  npm:        { osv: "npm",           gh: "npm",       paramKey: "package" },
  pypi:       { osv: "PyPI",          gh: "pip",       paramKey: "package" },
  maven:      { osv: "Maven",         gh: "maven",     paramKey: "artifact" },
  nuget:      { osv: "NuGet",         gh: "nuget",     paramKey: "package" },
  packagist:  { osv: "Packagist",     gh: "composer",  paramKey: "package" },
  crates:     { osv: "crates.io",     gh: "rust",      paramKey: "crate" },
  rubygems:   { osv: "RubyGems",      gh: "rubygems",  paramKey: "gem" },
  goproxy:    { osv: "Go",            gh: "go",        paramKey: "module" },
  homebrew:   { osv: null,            gh: null,        paramKey: "formula" },
  wordpress:  { osv: null,            gh: null,        paramKey: "slug" },
  dockerhub:  { osv: null,            gh: null,        paramKey: "image" },
  github:     { osv: null,            gh: null,        paramKey: "repo" },
  gitlab:     { osv: null,            gh: null,        paramKey: "project" },
  winget:     { osv: null,            gh: null,        paramKey: "packageId" },
  repology:   { osv: null,            gh: null,        paramKey: "project" },
  chrome:     { osv: null,            gh: null,        paramKey: "platform" },
  endoflife:  { osv: null,            gh: null,        paramKey: "product" },
  appstore:   { osv: null,            gh: null,        paramKey: "bundleId" },
  playstore:  { osv: null,            gh: null,        paramKey: "appId" },
  msstore:    { osv: null,            gh: null,        paramKey: "productId" },
  helm:       { osv: null,            gh: null,        paramKey: "chart" },
  snap:       { osv: null,            gh: null,        paramKey: "snap" },
  flathub:    { osv: null,            gh: null,        paramKey: "appId" },
  terraform:  { osv: null,            gh: null,        paramKey: "module" },
  chocolatey: { osv: null,            gh: null,        paramKey: "package" },
  pub:        { osv: "Pub",           gh: null,        paramKey: "package" },
  hex:        { osv: "Hex",           gh: "erlang",    paramKey: "package" },
  conda:      { osv: null,            gh: null,        paramKey: "package" },
  cocoapods:  { osv: "CocoaPods",     gh: null,        paramKey: "pod" },
  cpan:       { osv: "CPAN",          gh: null,        paramKey: "distribution" },
  fdroid:     { osv: null,            gh: null,        paramKey: "appId" },
  firefox_addon: { osv: null,         gh: null,        paramKey: "slug" },
  vscode:     { osv: null,            gh: null,        paramKey: "extensionId" },
  jetbrains:  { osv: null,            gh: null,        paramKey: "pluginId" },
  openvsx:    { osv: null,            gh: null,        paramKey: "extensionId" },
  aur:        { osv: null,            gh: null,        paramKey: "package" },
  ansible:    { osv: null,            gh: null,        paramKey: "collection" },
  quay:       { osv: null,            gh: null,        paramKey: "repository" },
  bitbucket:  { osv: null,            gh: null,        paramKey: "repo" },
  libraries_io: { osv: null,         gh: null,        paramKey: "package" },
};

function resolveEcosystem(sourceType: string, params: Record<string, string>, itemName: string): EcosystemMapping {
  const mapping = SOURCE_ECOSYSTEM_MAP[sourceType];
  const paramKey = mapping?.paramKey ?? "";
  const packageName = params[paramKey] || null;

  return {
    osvEcosystem: mapping?.osv ?? null,
    ghEcosystem: mapping?.gh ?? null,
    packageName,
    nvdKeyword: packageName || itemName,
  };
}

export async function enrichItemCves(input: EnrichmentInput): Promise<void> {
  const enabled = await getAppSetting("cve_enrichment_enabled");
  if (!isCveEnrichmentEnabled(enabled)) return;

  const { id, name, currentVersion, latestVersion, sourceType, sourceParams } = input;
  const version = currentVersion || "";
  const eco = resolveEcosystem(sourceType, sourceParams, name);

  const queries: Promise<CveProviderResult>[] = [];

  if (eco.osvEcosystem && eco.packageName && version) {
    queries.push(
      queryOsv(eco.osvEcosystem, eco.packageName, version)
        .then((cves) => ({ source: "osv" as const, cves }))
        .catch(() => ({ source: "osv", cves: [] }))
    );
  }

  queries.push(
    queryNvd(eco.nvdKeyword, version)
      .then((cves) => ({ source: "nvd" as const, cves }))
      .catch(() => ({ source: "nvd", cves: [] }))
  );

  // GitHub advisories endpoint here is package-level and not strict version-aware,
  // so we only use it when current version is unknown to reduce false positives.
  if (eco.ghEcosystem && eco.packageName && !version) {
    queries.push(
      queryGitHubAdvisory(eco.ghEcosystem, eco.packageName)
        .then((cves) => ({ source: "github_advisory" as const, cves }))
        .catch(() => ({ source: "github_advisory", cves: [] }))
    );
  }

  queries.push(
    queryVulnDb(eco.nvdKeyword, version)
      .then((r) => ({ source: "vulndb" as const, cves: r.cves }))
      .catch(() => ({ source: "vulndb", cves: [] }))
  );

  const results = await Promise.allSettled(queries);

  const allCves = new Set<string>();
  const cvesBySource: Record<string, Set<string>> = {
    osv: new Set<string>(),
    nvd: new Set<string>(),
    github_advisory: new Set<string>(),
    vulndb: new Set<string>(),
  };

  for (const result of results) {
    if (result.status === "fulfilled") {
      for (const cve of result.value.cves) {
        allCves.add(cve);
        cvesBySource[result.value.source].add(cve);
      }
    }
  }

  const sortedCves = [...allCves].sort();
  const existingItem = await prisma.monitoredItem.findUnique({
    where: { id },
    select: { cves: true, rawMetadata: true },
  });
  let existingSorted: string[] = [];
  try {
    const parsed = existingItem?.cves ? JSON.parse(existingItem.cves) : [];
    if (Array.isArray(parsed)) {
      existingSorted = parsed.map((v) => String(v)).sort();
    }
  } catch {
    existingSorted = [];
  }

  const hasCveChanges =
    sortedCves.length !== existingSorted.length ||
    sortedCves.some((cve, index) => cve !== existingSorted[index]);

  if (hasCveChanges) {
    let rawMetadata: Record<string, unknown> = {};
    try {
      rawMetadata =
        existingItem?.rawMetadata && typeof existingItem.rawMetadata === "string"
          ? (JSON.parse(existingItem.rawMetadata) as Record<string, unknown>)
          : {};
    } catch {
      rawMetadata = {};
    }

    const countsBySource = Object.fromEntries(
      Object.entries(cvesBySource).map(([source, values]) => [source, values.size])
    );

    rawMetadata.cveMetadata = {
      versionQueried: version || null,
      total: sortedCves.length,
      countsBySource,
      updatedAt: new Date().toISOString(),
    };

    await prisma.monitoredItem.update({
      where: { id },
      data: {
        cves: sortedCves.length > 0 ? JSON.stringify(sortedCves) : null,
        status: sortedCves.length > 0 ? "critical" : deriveStatusFromVersions(currentVersion, latestVersion),
        rawMetadata: JSON.stringify(rawMetadata),
      },
    });
    const updatedItem = await prisma.monitoredItem.findUnique({
      where: { id },
      include: { source: { select: { id: true, name: true, type: true } } },
    });
    publishCheckEvent({
      type: "check_progress",
      itemId: id,
      itemName: name,
      status: updatedItem?.status ?? undefined,
      item: updatedItem ?? undefined,
    });
    const delta = sortedCves.length - existingSorted.length;
    const operation = delta >= 0 ? `+${delta}` : `${delta}`;
    console.log(`[CVE Enrichment] ${name}: CVE set updated (${operation}, total: ${sortedCves.length})`);
  }
}
