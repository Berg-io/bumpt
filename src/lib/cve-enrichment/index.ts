import { prisma } from "@/lib/prisma";
import { getAppSetting } from "@/lib/settings";
import { queryOsv } from "./osv";
import { queryNvd } from "./nvd";
import { queryGitHubAdvisory } from "./github-advisory";
import { queryEpssByCve } from "./epss";
import { queryCisaKevMatches } from "./cisa-kev";
import { queryVulnDb } from "@/lib/version-checkers/vulndb";
import { publishCheckEvent } from "@/lib/check-events";
import { computeExternalScore, computeInternalScore } from "@/lib/risk-score";
import { enrichCveWithAI } from "@/lib/ai-enrichment";

interface EnrichmentInput {
  id: string;
  name: string;
  currentVersion: string | null;
  latestVersion: string | null;
  sourceType: string;
  sourceParams: Record<string, string>;
}

interface EcosystemMapping {
  osvEcosystem: string | null;
  ghEcosystem: string | null;
  packageName: string | null;
  nvdKeyword: string;
  keywordCandidates: string[];
}

interface CveProviderResult {
  source: "osv" | "nvd" | "github_advisory" | "vulndb";
  cves: string[];
  vulnerabilities?: Array<{
    severity: string | null;
    cvssScore: number | null;
  }>;
}

function extractAiRiskSummary(payload: unknown): string | null {
  if (!payload || typeof payload !== "object") return null;
  const generated = (payload as { ai_generated_data?: unknown }).ai_generated_data;
  if (!generated || typeof generated !== "object") return null;
  const summary = (generated as { risk_summary?: unknown }).risk_summary;
  return typeof summary === "string" && summary.trim() ? summary : null;
}

function normalizeVersionParts(version: string | null | undefined): number[] {
  if (!version) return [];
  return version
    .replace(/^[^\d]*/, "")
    .replace(/[^0-9.].*$/, "")
    .split(".")
    .map((part) => Number(part))
    .filter((part) => Number.isFinite(part));
}

function compareNormalizedVersions(a: string | null | undefined, b: string | null | undefined): number {
  const ap = normalizeVersionParts(a);
  const bp = normalizeVersionParts(b);
  const max = Math.max(ap.length, bp.length);
  for (let i = 0; i < max; i++) {
    const av = ap[i] ?? 0;
    const bv = bp[i] ?? 0;
    if (av > bv) return 1;
    if (av < bv) return -1;
  }
  return 0;
}

function isEolPast(eolDate: string | null | undefined): boolean {
  if (!eolDate || eolDate === "false") return false;
  if (eolDate === "true") return true;
  const d = new Date(eolDate);
  return !isNaN(d.getTime()) && d < new Date();
}

function deriveStatusFromVersions(
  current: string | null,
  latest: string | null,
  eolDate?: string | null
): "up_to_date" | "outdated" | "end_of_life" {
  if (isEolPast(eolDate)) return "end_of_life";
  if (!current || !latest) return "up_to_date";
  if (current === latest) return "up_to_date";
  return compareNormalizedVersions(latest, current) > 0 ? "outdated" : "up_to_date";
}

function isCveEnrichmentEnabled(setting: string | null): boolean {
  if (!setting) return false;
  const normalized = setting.trim().toLowerCase();
  return normalized === "true" || normalized === "1" || normalized === "yes" || normalized === "on";
}

const SOURCE_ECOSYSTEM_MAP: Record<string, { osv: string | null; gh: string | null; paramKey: string }> = {
  npm:        { osv: "npm",           gh: "npm",       paramKey: "package" },
  pypi:       { osv: "PyPI",          gh: "pip",       paramKey: "package" },
  maven:      { osv: "Maven",         gh: "maven",     paramKey: "artifact" },
  nuget:      { osv: "NuGet",         gh: "nuget",     paramKey: "package" },
  packagist:  { osv: "Packagist",     gh: "composer",  paramKey: "package" },
  crates:     { osv: "crates.io",     gh: "rust",      paramKey: "crate" },
  rubygems:   { osv: "RubyGems",      gh: "rubygems",  paramKey: "gem" },
  goproxy:    { osv: "Go",            gh: "go",        paramKey: "module" },
  homebrew:   { osv: null,            gh: null,        paramKey: "formula" },
  wordpress:  { osv: null,            gh: null,        paramKey: "slug" },
  dockerhub:  { osv: null,            gh: null,        paramKey: "image" },
  github:     { osv: null,            gh: null,        paramKey: "repo" },
  gitlab:     { osv: null,            gh: null,        paramKey: "project" },
  winget:     { osv: null,            gh: null,        paramKey: "packageId" },
  repology:   { osv: null,            gh: null,        paramKey: "project" },
  chrome:     { osv: null,            gh: null,        paramKey: "platform" },
  endoflife:  { osv: null,            gh: null,        paramKey: "product" },
  appstore:   { osv: null,            gh: null,        paramKey: "bundleId" },
  playstore:  { osv: null,            gh: null,        paramKey: "appId" },
  msstore:    { osv: null,            gh: null,        paramKey: "productId" },
  helm:       { osv: null,            gh: null,        paramKey: "chart" },
  snap:       { osv: null,            gh: null,        paramKey: "snap" },
  flathub:    { osv: null,            gh: null,        paramKey: "appId" },
  terraform:  { osv: null,            gh: null,        paramKey: "module" },
  chocolatey: { osv: null,            gh: null,        paramKey: "package" },
  pub:        { osv: "Pub",           gh: null,        paramKey: "package" },
  hex:        { osv: "Hex",           gh: "erlang",    paramKey: "package" },
  conda:      { osv: null,            gh: null,        paramKey: "package" },
  cocoapods:  { osv: "CocoaPods",     gh: null,        paramKey: "pod" },
  cpan:       { osv: "CPAN",          gh: null,        paramKey: "distribution" },
  fdroid:     { osv: null,            gh: null,        paramKey: "appId" },
  firefox_addon: { osv: null,         gh: null,        paramKey: "slug" },
  vscode:     { osv: null,            gh: null,        paramKey: "extensionId" },
  jetbrains:  { osv: null,            gh: null,        paramKey: "pluginId" },
  openvsx:    { osv: null,            gh: null,        paramKey: "extensionId" },
  aur:        { osv: null,            gh: null,        paramKey: "package" },
  ansible:    { osv: null,            gh: null,        paramKey: "collection" },
  quay:       { osv: null,            gh: null,        paramKey: "repository" },
  bitbucket:  { osv: null,            gh: null,        paramKey: "repo" },
  libraries_io: { osv: null,         gh: null,        paramKey: "package" },
};

function cleanKeyword(value: string | null | undefined): string {
  if (!value) return "";
  const noProtocol = value.replace(/^https?:\/\//i, "");
  const noTag = noProtocol.split("@")[0]?.split(":")[0] ?? noProtocol;
  return noTag
    .replace(/[^a-zA-Z0-9._/\- ]+/g, " ")
    .replace(/[_\-./]+/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function extractLastSegment(value: string | null | undefined): string {
  if (!value) return "";
  const normalized = value.replace(/\/+$/, "");
  const segments = normalized.split("/");
  return segments[segments.length - 1] ?? "";
}

function buildKeywordCandidates(sourceType: string, params: Record<string, string>, itemName: string): string[] {
  const values = new Set<string>();
  const add = (raw?: string | null) => {
    const cleaned = cleanKeyword(raw);
    if (cleaned.length >= 2) values.add(cleaned);
  };

  const mapping = SOURCE_ECOSYSTEM_MAP[sourceType];
  const primaryParam = mapping?.paramKey ? params[mapping.paramKey] : null;
  add(primaryParam);
  add(extractLastSegment(primaryParam));
  add(itemName);
  add(extractLastSegment(itemName));

  // Extra hints for repo/image-like sources.
  if (sourceType === "dockerhub" || sourceType === "github" || sourceType === "gitlab" || sourceType === "quay") {
    add(params.image);
    add(params.repo);
    add(params.project);
    add(params.repository);
    add(extractLastSegment(params.image));
    add(extractLastSegment(params.repo));
    add(extractLastSegment(params.project));
    add(extractLastSegment(params.repository));
  }

  return [...values];
}

function resolveEcosystem(sourceType: string, params: Record<string, string>, itemName: string): EcosystemMapping {
  const mapping = SOURCE_ECOSYSTEM_MAP[sourceType];
  const paramKey = mapping?.paramKey ?? "";
  const packageName = params[paramKey] || null;
  const keywordCandidates = buildKeywordCandidates(sourceType, params, itemName);
  const nvdKeyword = keywordCandidates[0] || packageName || itemName;

  return {
    osvEcosystem: mapping?.osv ?? null,
    ghEcosystem: mapping?.gh ?? null,
    packageName,
    nvdKeyword,
    keywordCandidates,
  };
}

export async function enrichItemCves(input: EnrichmentInput): Promise<void> {
  const enabled = await getAppSetting("cve_enrichment_enabled");
  if (!isCveEnrichmentEnabled(enabled)) return;

  const { id, name, currentVersion, latestVersion, sourceType, sourceParams } = input;
  const version = currentVersion || "";
  const eco = resolveEcosystem(sourceType, sourceParams, name);

  const queries: Promise<CveProviderResult>[] = [];

  if (eco.osvEcosystem && eco.packageName && version) {
    queries.push(
      queryOsv(eco.osvEcosystem, eco.packageName, version)
        .then((cves) => ({ source: "osv" as const, cves }))
        .catch(() => ({ source: "osv", cves: [] }))
    );
  }

  queries.push(
    (async () => {
      const nvdCves = new Set<string>();
      const toTry = eco.keywordCandidates.slice(0, 3);
      for (const keyword of toTry) {
        try {
          const cves = await queryNvd(keyword, version);
          for (const cve of cves) nvdCves.add(cve);
          if (nvdCves.size > 0) break;
        } catch {
          // continue fallback keywords
        }
      }
      return { source: "nvd" as const, cves: [...nvdCves] };
    })().catch(() => ({ source: "nvd", cves: [] }))
  );

  // GitHub advisories endpoint here is package-level and not strict version-aware,
  // so we only use it when current version is unknown to reduce false positives.
  if (eco.ghEcosystem && eco.packageName && !version) {
    queries.push(
      queryGitHubAdvisory(eco.ghEcosystem, eco.packageName)
        .then((cves) => ({ source: "github_advisory" as const, cves }))
        .catch(() => ({ source: "github_advisory", cves: [] }))
    );
  }

  queries.push(
    (async () => {
      const vulnDbCves = new Set<string>();
      const vulnerabilities: NonNullable<CveProviderResult["vulnerabilities"]> = [];
      const toTry = eco.keywordCandidates.slice(0, 3);
      for (const keyword of toTry) {
        try {
          const r = await queryVulnDb(keyword, version);
          for (const cve of r.cves) vulnDbCves.add(cve);
          if (r.vulnerabilities.length > 0 && vulnerabilities.length === 0) {
            vulnerabilities.push(...r.vulnerabilities);
          }
          if (vulnDbCves.size > 0 || vulnerabilities.length > 0) break;
        } catch {
          // continue fallback keywords
        }
      }
      return { source: "vulndb" as const, cves: [...vulnDbCves], vulnerabilities };
    })().catch(() => ({ source: "vulndb", cves: [] }))
  );

  const results = await Promise.allSettled(queries);

  const allCves = new Set<string>();
  const cvesBySource: Record<string, Set<string>> = {
    osv: new Set<string>(),
    nvd: new Set<string>(),
    github_advisory: new Set<string>(),
    vulndb: new Set<string>(),
  };

  for (const result of results) {
    if (result.status === "fulfilled") {
      for (const cve of result.value.cves) {
        allCves.add(cve);
        cvesBySource[result.value.source].add(cve);
      }
    }
  }

  const sortedCves = [...allCves].sort();
  const [epssByCve, kevMatches] = sortedCves.length > 0
    ? await Promise.all([queryEpssByCve(sortedCves), queryCisaKevMatches(sortedCves)])
    : [{}, [] as string[]];
  const maxEpssPercent = Object.values(epssByCve).reduce<number | null>((max, value) => {
    if (!Number.isFinite(value)) return max;
    return max === null ? value : Math.max(max, value);
  }, null);

  const existingItem = await prisma.monitoredItem.findUnique({
    where: { id },
    select: {
      cves: true,
      rawMetadata: true,
      assetCriticality: true,
      environment: true,
      networkExposure: true,
      hostsSensitiveData: true,
      hasPrivilegedAccess: true,
      hasCompensatingControls: true,
      eolDate: true,
      externalScore: true,
      externalSeverity: true,
      externalSource: true,
      internalScore: true,
      internalSeverity: true,
      scoreConfidence: true,
      securityState: true,
      releaseNotes: true,
      description: true,
    },
  });
  let existingSorted: string[] = [];
  try {
    const parsed = existingItem?.cves ? JSON.parse(existingItem.cves) : [];
    if (Array.isArray(parsed)) {
      existingSorted = parsed.map((v) => String(v)).sort();
    }
  } catch {
    existingSorted = [];
  }

  const hasCveChanges =
    sortedCves.length !== existingSorted.length ||
    sortedCves.some((cve, index) => cve !== existingSorted[index]);

  let rawMetadata: Record<string, unknown> = {};
  try {
    rawMetadata =
      existingItem?.rawMetadata && typeof existingItem.rawMetadata === "string"
        ? (JSON.parse(existingItem.rawMetadata) as Record<string, unknown>)
        : {};
  } catch {
    rawMetadata = {};
  }

  const countsBySource = Object.fromEntries(
    Object.entries(cvesBySource).map(([source, values]) => [source, values.size])
  );

  const vulndbFulfilled = results
    .filter((result): result is PromiseFulfilledResult<CveProviderResult> => result.status === "fulfilled")
    .find((result) => result.value.source === "vulndb");

  const vulndbVulns = vulndbFulfilled?.value.vulnerabilities ?? [];
  const maxCvss = vulndbVulns.reduce<number | null>((max, vuln) => {
    if (typeof vuln.cvssScore !== "number") return max;
    return max === null ? vuln.cvssScore : Math.max(max, vuln.cvssScore);
  }, null);
  const firstSeverity = vulndbVulns.find((vuln) => typeof vuln.severity === "string")?.severity ?? null;

  const external = computeExternalScore({
    cvssV3: maxCvss,
    epssPercent: maxEpssPercent,
    severityText: firstSeverity,
    source: vulndbVulns.length > 0 ? "vulndb" : sortedCves.length > 0 ? "mixed" : null,
    hasKnownCves: sortedCves.length > 0,
    cveCount: sortedCves.length,
    hasKnownExploited: kevMatches.length > 0,
    isEolPast: isEolPast(existingItem?.eolDate ?? null),
  });

  const internal = computeInternalScore(
    external.score,
    {
      assetCriticality: existingItem?.assetCriticality ?? null,
      environment: existingItem?.environment ?? null,
      networkExposure: existingItem?.networkExposure ?? null,
      hostsSensitiveData: existingItem?.hostsSensitiveData ?? null,
      hasPrivilegedAccess: existingItem?.hasPrivilegedAccess ?? null,
      hasCompensatingControls: existingItem?.hasCompensatingControls ?? null,
    },
    external.epssPercent,
    isEolPast(existingItem?.eolDate ?? null),
    sortedCves.length
  );

  const language = (await getAppSetting("app_language")) || "en";
  const aiEnrichment = await enrichCveWithAI({
    itemId: id,
    itemName: name,
    itemType: sourceType,
    currentVersion,
    latestVersion,
    cves: sortedCves,
    releaseNotes: existingItem?.releaseNotes ?? null,
    description: existingItem?.description ?? null,
    rawMetadata: JSON.stringify(rawMetadata).slice(0, 2000),
    externalScore: external.score,
    externalSeverity: external.severity,
    internalScore: internal.score,
    internalSeverity: internal.severity,
    language,
  }).catch((error) => {
    const message = error instanceof Error ? error.message : String(error);
    console.warn(`[AI Enrichment] ${name}: ${message.slice(0, 220)}`);
    return null;
  });

  rawMetadata.cveMetadata = {
    versionQueried: version || null,
    keywordCandidatesTried: eco.keywordCandidates.slice(0, 3),
    total: sortedCves.length,
    countsBySource,
    updatedAt: new Date().toISOString(),
    externalScoring: {
      score: external.score,
      severity: external.severity,
      source: external.source,
      vector: external.vector,
      epssPercent: external.epssPercent,
      vprScore: external.vprScore,
      sampleSize: vulndbVulns.length,
    },
    threatIntel: {
      epssMax: maxEpssPercent,
      kevMatchesCount: kevMatches.length,
      kevMatchedSample: kevMatches.slice(0, 10),
    },
    internalScoring: {
      score: internal.score,
      severity: internal.severity,
      confidence: internal.confidence,
    },
  };
  if (aiEnrichment) {
    rawMetadata.aiEnrichment = {
      markedAsAI: true,
      generatedAt: new Date().toISOString(),
      result: aiEnrichment,
    };
  }

  const shouldUpdateScores =
    external.score !== existingItem?.externalScore ||
    external.severity !== existingItem?.externalSeverity ||
    external.source !== existingItem?.externalSource ||
    internal.score !== existingItem?.internalScore ||
    internal.severity !== existingItem?.internalSeverity ||
    internal.confidence !== existingItem?.scoreConfidence;
  const nextSecurityState = sortedCves.length > 0 ? "vulnerable" : "no_known_vuln";
  const shouldUpdateSecurityState = nextSecurityState !== existingItem?.securityState;
  const shouldUpdateAI = Boolean(aiEnrichment);

  if (hasCveChanges || shouldUpdateScores || shouldUpdateSecurityState || shouldUpdateAI) {
    const updateData: Record<string, unknown> = {
      cves: sortedCves.length > 0 ? JSON.stringify(sortedCves) : null,
      status: deriveStatusFromVersions(currentVersion, latestVersion, existingItem?.eolDate ?? null),
      securityState: nextSecurityState,
      externalScore: external.score,
      externalSeverity: external.severity,
      externalSource: external.source,
      externalVector: external.vector,
      epssPercent: external.epssPercent,
      vprScore: external.vprScore,
      internalScore: internal.score,
      internalSeverity: internal.severity,
      scoreConfidence: internal.confidence,
      scoreUpdatedAt: new Date(),
      rawMetadata: JSON.stringify(rawMetadata),
    };
    const aiRiskSummary = extractAiRiskSummary(aiEnrichment);
    if (aiRiskSummary) {
      updateData.aiSummary = aiRiskSummary;
    }
    await prisma.monitoredItem.update({
      where: { id },
      data: updateData,
    });
    const updatedItem = await prisma.monitoredItem.findUnique({
      where: { id },
      include: { source: { select: { id: true, name: true, type: true } } },
    });
    publishCheckEvent({
      type: "check_progress",
      itemId: id,
      itemName: name,
      status: updatedItem?.status ?? undefined,
      item: updatedItem ?? undefined,
    });
    if (hasCveChanges) {
      const delta = sortedCves.length - existingSorted.length;
      const operation = delta >= 0 ? `+${delta}` : `${delta}`;
      console.log(`[CVE Enrichment] ${name}: CVE set updated (${operation}, total: ${sortedCves.length})`);
    }
  }
}
